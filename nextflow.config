manifest {
  description = 'Synteny analysis' 
  author = 'Chris Wyatt and Simon Murray'
}

// Defaults parameters, expecting to be overwritten
params {
  // Path to results directory
  outdir                     = "Results"
  // Path to input CSV
  input                      = null
  hex                        = "${projectDir}/data/unique_hex"
  go                         = null
  tree                       = null
  // Remove work directories upon pipeline completion
  clean                      = true
  // Architecture of platform pipeline is running on
  architecture               = "amd"
  // Max resource options
  max_memory                 = '24.GB'
  max_cpus                   =  16
  max_time                   = '24.h'
  // Custom config options
  custom_config              = null
}


// Load base.config by default for all pipelines
includeConfig 'conf/base.config'

// Select a combination of useful profiles i.e. nextflow run -profile local,docker 
profiles {
  local {
    executor.name            = 'local'
  }
  //Use Docker as the container management software
  docker {
    docker.enabled           = true
    // Remove docker containers after pipeline completes
    docker.remove            = true
    // Sets user for docker to the user who executes pipeline
    docker.runOptions        = '-u $(id -u):$(id -g)'
    // Ensure singularity is unset
    singularity.enabled      = false
  }
  singularity {
    singularity.enabled      = true
    // Set where singularity cached images are saved
    singularity.cacheDir     = "singularity/cachedir"
    // Ensure docker is unset
    docker.enabled           = false
  }
  test { includeConfig 'conf/test.config'       }
}

// Capture exit codes from upstream processes when piping
process.shell = ['/bin/bash', '-euo', 'pipefail']

// Capturing Nextflow log files into a rsults/pipeline_info directory
def trace_timestamp = new java.util.Date().format( 'yyyy-MM-dd_HH-mm-ss')
timeline {
    enabled = true
    file    = "${params.outdir}/pipeline_info/execution_timeline_${trace_timestamp}.html"
}
report {
    enabled = true
    file    = "${params.outdir}/pipeline_info/execution_report_${trace_timestamp}.html"
}
trace {
    enabled = true
    file    = "${params.outdir}/pipeline_info/execution_trace_${trace_timestamp}.txt"
}
dag {
    enabled = true
    file    = "${params.outdir}/pipeline_info/pipeline_dag_${trace_timestamp}.html"
}

// Ensures work directories and removed when pipeline completes
if (params.clean == true) {
   cleanup = true
}

// Function to ensure that resource requirements don't go beyond a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}
